<!DOCTYPE html>
<html>

<head>
    <title>FFT Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            border-bottom: 1px solid #333;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff00cc, #3333ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .visualization {
            flex-grow: 1;
            position: relative;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .meta-panel {
            display: flex;
            align-items: center;
        }

        .meta-item {
            margin-left: 20px;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .meta-label {
            font-size: 10px;
            color: #999;
            text-transform: uppercase;
        }

        .meta-value {
            font-size: 14px;
            font-weight: bold;
        }

        .status {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.6);
            z-index: 100;
            display: flex;
            align-items: center;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        .status-disconnected {
            background: #F44336;
        }

        .fps-counter {
            position: absolute;
            bottom: 15px;
            right: 15px;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.6);
            z-index: 100;
            font-size: 12px;
        }

        .vis-switcher {
            position: absolute;
            bottom: 15px;
            left: 15px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            z-index: 100;
            font-size: 12px;
            display: flex;
            align-items: center;
        }

        .vis-switcher button {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .vis-switcher button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .vis-switcher button.active {
            background: rgba(255, 255, 255, 0.3);
        }

        .help-tooltip {
            position: absolute;
            bottom: 55px;
            left: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            z-index: 100;
            font-size: 12px;
            max-width: 300px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .help-tooltip.visible {
            opacity: 1;
        }

        .vis-name {
            margin-right: 15px;
            font-weight: bold;
            color: #66ccff;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>FFT Visualizer</h1>
            <div class="meta-panel">
                <div class="meta-item">
                    <div class="meta-label">FFT Size</div>
                    <div class="meta-value" id="fft-size">-</div>
                </div>
                <div class="meta-item">
                    <div class="meta-label">Energy</div>
                    <div class="meta-value" id="energy">-</div>
                </div>
                <div class="meta-item">
                    <div class="meta-label">Window</div>
                    <div class="meta-value" id="window-type">-</div>
                </div>
            </div>
        </header>

        <div class="visualization">
            <canvas id="canvas"></canvas>
            <div class="status">
                <div class="status-indicator status-disconnected" id="status-indicator"></div>
                <span id="status-text">Disconnected</span>
            </div>
            <div class="fps-counter">FPS: <span id="fps">0</span></div>
            <div class="vis-switcher">
                <span class="vis-name" id="vis-name">Wave</span>
                <button id="prev-vis">◀</button>
                <button id="next-vis">▶</button>
            </div>
            <div class="help-tooltip" id="help-tooltip">
                <strong>Keyboard Shortcuts:</strong><br>
                Space - Next visualization<br>
                Left/Right - Previous/Next visualization<br>
                1-6 - Select visualization directly<br>
                H - Toggle this help
            </div>
        </div>
    </div>

    <script>
        // Constants
        const windowNames = ["Rectangle", "Bartlett", "BartlettHann", "Blackman",
            "BlackmanNuttall", "Cosine", "Gauss", "Hamming",
            "Hann", "Lanczos", "Rectangular", "Triangular"];

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Status elements
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');

        // Metadata elements
        const fftSizeEl = document.getElementById('fft-size');
        const energyEl = document.getElementById('energy');
        const windowTypeEl = document.getElementById('window-type');
        const fpsEl = document.getElementById('fps');
        const visNameEl = document.getElementById('vis-name');
        const helpTooltip = document.getElementById('help-tooltip');

        // Visualization parameters
        let fftData = [];
        let energy = 0;
        let baseColor = [0, 128, 255]; // RGB base color

        // Visualization type
        const visualizations = [
            { name: 'Wave', render: renderWave },
            { name: 'Bars', render: renderBars },
            { name: 'Circular', render: renderCircular },
            { name: 'Particles', render: renderParticles },
            { name: '3D Grid', render: render3DGrid },
            { name: 'Spectrogram', render: renderSpectrogram }
        ];

        let currentVisIndex = 0;
        let particles = []; // For particle visualization
        let spectrogramHistory = []; // For spectrogram visualization

        // Button handlers
        document.getElementById('prev-vis').addEventListener('click', () => {
            currentVisIndex = (currentVisIndex - 1 + visualizations.length) % visualizations.length;
            updateVisualizationName();
        });

        document.getElementById('next-vis').addEventListener('click', () => {
            currentVisIndex = (currentVisIndex + 1) % visualizations.length;
            updateVisualizationName();
        });

        function updateVisualizationName() {
            visNameEl.textContent = visualizations[currentVisIndex].name;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case ' ':
                case 'ArrowRight':
                    currentVisIndex = (currentVisIndex + 1) % visualizations.length;
                    updateVisualizationName();
                    break;
                case 'ArrowLeft':
                    currentVisIndex = (currentVisIndex - 1 + visualizations.length) % visualizations.length;
                    updateVisualizationName();
                    break;
                case 'h':
                case 'H':
                    helpTooltip.classList.toggle('visible');
                    break;
                case '1': case '2': case '3': case '4': case '5': case '6':
                    const index = parseInt(e.key) - 1;
                    if (index < visualizations.length) {
                        currentVisIndex = index;
                        updateVisualizationName();
                    }
                    break;
            }
        });

        // Initialization
        let frameCount = 0;
        let lastTime = performance.now();

        // Set up high DPI canvas
        function setupCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            ctx.scale(dpr, dpr);
        }

        // Smooth the FFT data for more pleasing visuals
        function smoothArray(array, smoothFactor) {
            if (array.length < 2) return array;

            const result = new Array(array.length);
            result[0] = array[0];

            for (let i = 1; i < array.length - 1; i++) {
                result[i] = array[i - 1] * smoothFactor +
                    array[i] * (1 - 2 * smoothFactor) +
                    array[i + 1] * smoothFactor;
            }

            result[array.length - 1] = array[array.length - 1];
            return result;
        }

        // Draw the visualization
        function draw() {
            // Set up frame timing
            const now = performance.now();
            frameCount++;

            if (now - lastTime > 1000) {
                fpsEl.textContent = Math.round(frameCount * 1000 / (now - lastTime));
                frameCount = 0;
                lastTime = now;
            }

            // Clear canvas
            const width = canvas.width / window.devicePixelRatio;
            const height = canvas.height / window.devicePixelRatio;
            ctx.clearRect(0, 0, width, height);

            // Render the current visualization
            if (fftData.length) {
                visualizations[currentVisIndex].render(ctx, width, height);
            }

            // Request next frame
            requestAnimationFrame(draw);
        }

        // Visualization 1: Wave (original)
        function renderWave(ctx, width, height) {
            // Use the energy to make color more intense
            const colorIntensity = Math.min(1, energy * 5);
            const r = Math.round(baseColor[0] + (255 - baseColor[0]) * colorIntensity);
            const g = Math.round(baseColor[1] * (1 - colorIntensity * 0.5));
            const b = Math.round(baseColor[2] * (1 - colorIntensity * 0.7));

            // Create gradient for wave
            const gradient = ctx.createLinearGradient(0, height, 0, 0);
            gradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.3)`);

            // Smooth the FFT data for nicer visuals
            const smoothedData = smoothArray(fftData, 0.2);

            // Draw FFT wave using logarithmic scale
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, height);

            for (let i = 0; i < smoothedData.length; i++) {
                const x = i === 0 ? 0 : Math.log(i) / Math.log(smoothedData.length) * width;
                const value = Math.pow(smoothedData[i], 0.8);
                const barHeight = value * height * (1 + energy * 0.5);
                ctx.lineTo(x, height - barHeight);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();

            // Add reflection effect
            ctx.fillStyle = "rgba(255,255,255,0.1)";
            ctx.fillRect(0, height - 2, width, 2);

            // Add glow effect based on energy
            if (energy > 0.2) {
                ctx.shadowBlur = 15 * energy;
                ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.7)`;

                ctx.beginPath();
                for (let i = 0; i < smoothedData.length; i += 3) {
                    if (smoothedData[i] > 0.7) {
                        const x = i === 0 ? 0 : Math.log(i) / Math.log(smoothedData.length) * width;
                        const barHeight = smoothedData[i] * height * (1 + energy);

                        ctx.moveTo(x, height - barHeight);
                        ctx.lineTo(x, height - barHeight - 5 * energy);
                    }
                }
                ctx.stroke();

                ctx.shadowBlur = 0;
            }
        }

        // Visualization 2: Bars
        function renderBars(ctx, width, height) {
            const colorIntensity = Math.min(1, energy * 5);
            const r = Math.round(baseColor[0] + (255 - baseColor[0]) * colorIntensity);
            const g = Math.round(baseColor[1] * (1 - colorIntensity * 0.5));
            const b = Math.round(baseColor[2] * (1 - colorIntensity * 0.7));

            const smoothedData = smoothArray(fftData, 0.15);
            const barCount = Math.min(smoothedData.length, 128);
            const barWidth = width / barCount;

            // Draw bars
            for (let i = 0; i < barCount; i++) {
                // Use log scale for frequency
                const logI = Math.pow(i / barCount, 1.4) * barCount;
                const dataIndex = Math.floor(logI);

                // Get value and apply easing
                const value = Math.pow(smoothedData[dataIndex], 0.7);
                const barHeight = value * height * 0.9;

                // Calculate bar position
                const x = i * barWidth;

                // Create gradient for each bar
                const gradient = ctx.createLinearGradient(0, height, 0, height - barHeight);
                gradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
                gradient.addColorStop(1, `rgba(${r + 40}, ${g + 40}, ${b + 40}, 0.7)`);

                // Draw the bar
                ctx.fillStyle = gradient;
                ctx.fillRect(x, height - barHeight, barWidth - 1, barHeight);

                // Add highlight if energy is high
                if (value > 0.7) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${value * 0.3})`;
                    ctx.fillRect(x, height - barHeight, barWidth - 1, 4);
                }
            }

            // Add reflections
            ctx.fillStyle = "rgba(255,255,255,0.06)";
            ctx.fillRect(0, height - 1, width, 1);
        }

        // Visualization 3: Circular
        function renderCircular(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;

            const colorIntensity = Math.min(1, energy * 5);
            const r = Math.round(baseColor[0] + (255 - baseColor[0]) * colorIntensity);
            const g = Math.round(baseColor[1] * (1 - colorIntensity * 0.5));
            const b = Math.round(baseColor[2] * (1 - colorIntensity * 0.7));

            const smoothedData = smoothArray(fftData, 0.2);
            const segments = Math.min(smoothedData.length, 180);

            // Draw circular visualization
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
            ctx.lineWidth = 2;

            // Outer circle
            ctx.beginPath();
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const value = smoothedData[i % smoothedData.length] * (1 + energy);
                const distance = radius + value * radius * 0.5;

                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            // Add glow
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.7)`;
            ctx.shadowBlur = 15 * (0.5 + energy);
            ctx.stroke();

            // Inner circle with mirror effect
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.3;

            ctx.beginPath();
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const value = smoothedData[i % smoothedData.length] * (0.8 + energy * 0.5);
                const distance = radius - value * radius * 0.3;

                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();

            ctx.globalAlpha = 1;
        }

        // Visualization 4: Particles
        function renderParticles(ctx, width, height) {
            // Use the energy to make color more intense
            const colorIntensity = Math.min(1, energy * 5);
            const r = Math.round(baseColor[0] + (255 - baseColor[0]) * colorIntensity);
            const g = Math.round(baseColor[1] * (1 - colorIntensity * 0.5));
            const b = Math.round(baseColor[2] * (1 - colorIntensity * 0.7));

            // Initialize particles if needed
            if (particles.length === 0) {
                initParticles(width, height);
            }

            // Update particles based on FFT data
            updateParticles(width, height);

            // Draw particles
            ctx.shadowBlur = 8 * energy;
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.7)`;

            for (let p of particles) {
                const alpha = Math.min(1, p.life);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;
        }

        function initParticles(width, height) {
            const particleCount = 200;
            particles = [];

            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: 1 + Math.random() * 3,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 2,
                    life: Math.random()
                });
            }
        }

        function updateParticles(width, height) {
            if (!fftData.length) return;

            const smoothedData = smoothArray(fftData, 0.3);
            const bassEnergy = getBandEnergy(smoothedData, 0, 10) * 5;
            const midEnergy = getBandEnergy(smoothedData, 10, 30) * 3;
            const highEnergy = getBandEnergy(smoothedData, 30, smoothedData.length) * 2;

            for (let p of particles) {
                // Update position
                p.x += p.speedX * (1 + bassEnergy);
                p.y += p.speedY * (1 + midEnergy);

                // Bounce off walls
                if (p.x < 0 || p.x > width) {
                    p.speedX *= -1;
                }
                if (p.y < 0 || p.y > height) {
                    p.speedY *= -1;
                }

                // Update life based on high frequencies
                p.life -= 0.01;
                if (p.life <= 0) {
                    p.life = 1;
                    p.x = Math.random() * width;
                    p.y = Math.random() * height;
                    p.size = 1 + Math.random() * 3 + highEnergy * 2;
                }

                // Grow particles based on energy
                p.size = Math.max(1, p.size + (energy * 0.1) - 0.05);
            }
        }

        function getBandEnergy(data, start, end) {
            let sum = 0;
            for (let i = start; i < Math.min(end, data.length); i++) {
                sum += data[i];
            }
            return sum / (end - start);
        }

        // Visualization 5: 3D Grid
        function render3DGrid(ctx, width, height) {
            const colorIntensity = Math.min(1, energy * 5);
            const r = Math.round(baseColor[0] + (255 - baseColor[0]) * colorIntensity);
            const g = Math.round(baseColor[1] * (1 - colorIntensity * 0.5));
            const b = Math.round(baseColor[2] * (1 - colorIntensity * 0.7));

            const smoothedData = smoothArray(fftData, 0.15);

            // Grid parameters
            const cellsX = 20;
            const cellsZ = 10;
            const cellWidth = width / cellsX;
            const cellDepth = height * 0.7 / cellsZ;

            // 3D perspective parameters
            const vanishingPointX = width / 2;
            const vanishingPointY = height * 0.4;
            const zScale = 0.8; // Perspective scaling

            // Draw grid from back to front
            for (let z = cellsZ - 1; z >= 0; z--) {
                // Calculate perspective scale for this row
                const rowScale = 1 - (z / cellsZ) * (1 - zScale);
                const rowWidth = width * rowScale;
                const rowX = (width - rowWidth) / 2;
                const rowY = vanishingPointY + (height - vanishingPointY) * (z / cellsZ);

                // Draw cells in the row
                for (let x = 0; x < cellsX; x++) {
                    // Get FFT data for this cell
                    const dataIndex = Math.floor((x / cellsX) * smoothedData.length);
                    const value = smoothedData[dataIndex];

                    // Calculate height of the bar
                    const freqFactor = 1 - Math.abs((x - cellsX / 2) / (cellsX / 2));
                    const barHeightFactor = value * freqFactor * (1 + energy * 0.5);
                    const barHeight = barHeightFactor * height * 0.3;

                    // Calculate cell position in perspective
                    const cellX = rowX + (x / cellsX) * rowWidth;
                    const cellY = rowY;
                    const cellW = rowWidth / cellsX;

                    // Draw the bar
                    const alpha = 0.2 + (1 - z / cellsZ) * 0.8; // Fade with distance
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                    if (barHeight > 0) {
                        ctx.fillRect(cellX, cellY - barHeight, cellW, barHeight);

                        // Add highlight to top of bar
                        if (barHeight > 10) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                            ctx.fillRect(cellX, cellY - barHeight, cellW, 2);
                        }
                    }
                }

                // Draw horizontal grid line
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                ctx.beginPath();
                ctx.moveTo(rowX, rowY);
                ctx.lineTo(rowX + rowWidth, rowY);
                ctx.stroke();
            }

            // Draw vertical grid lines
            for (let x = 0; x <= cellsX; x++) {
                const frontX = (x / cellsX) * width;
                const backX = (width - width * zScale) / 2 + (x / cellsX) * width * zScale;

                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                ctx.beginPath();
                ctx.moveTo(frontX, height);
                ctx.lineTo(backX, vanishingPointY + (height - vanishingPointY) * ((cellsZ - 1) / cellsZ));
                ctx.stroke();
            }
        }

        // Visualization 6: Spectrogram
        function renderSpectrogram(ctx, width, height) {
            // Store current FFT data in history
            if (fftData.length) {
                // Create a copy with reduced data points
                const dataPoints = 128;
                const resampledData = [];

                for (let i = 0; i < dataPoints; i++) {
                    const sourceIdx = Math.floor((i / dataPoints) * fftData.length);
                    resampledData[i] = fftData[sourceIdx];
                }

                spectrogramHistory.unshift(resampledData);

                // Limit history size
                const maxHistory = 100;
                if (spectrogramHistory.length > maxHistory) {
                    spectrogramHistory.pop();
                }
            }

            // Draw the spectrogram
            const rowHeight = height / 100;

            for (let z = 0; z < spectrogramHistory.length; z++) {
                const data = spectrogramHistory[z];
                const y = z * rowHeight;

                // Draw each frequency bin as a colored pixel
                for (let i = 0; i < data.length; i++) {
                    // Use log scale for frequency
                    const logI = Math.pow(i / data.length, 1.4) * data.length;
                    const x = (logI / data.length) * width;
                    const value = data[i];

                    // Get color based on value
                    const color = getHeatmapColor(value);
                    ctx.fillStyle = color;

                    // Draw pixel (stretched to fill width)
                    const pixelWidth = width / data.length;
                    ctx.fillRect(x, y, pixelWidth, rowHeight);
                }
            }
        }

        // Helper for spectrogram - get color from value
        function getHeatmapColor(value) {
            // Value range: 0-1
            value = Math.min(1, value * 1.5); // Boost for visibility

            // Color stops for heatmap
            const stops = [
                { pos: 0.0, r: 0, g: 0, b: 0 },      // Black
                { pos: 0.2, r: 0, g: 0, b: 128 },    // Deep blue
                { pos: 0.4, r: 0, g: 255, b: 255 },  // Cyan
                { pos: 0.6, r: 0, g: 255, b: 0 },    // Green
                { pos: 0.8, r: 255, g: 255, b: 0 },  // Yellow
                { pos: 1.0, r: 255, g: 0, b: 0 }     // Red
            ];

            // Find the two stops we're between
            let stop1 = stops[0];
            let stop2 = stops[stops.length - 1];

            for (let i = 0; i < stops.length - 1; i++) {
                if (value >= stops[i].pos && value <= stops[i + 1].pos) {
                    stop1 = stops[i];
                    stop2 = stops[i + 1];
                    break;
                }
            }

            // Interpolate between the stops
            const range = stop2.pos - stop1.pos;
            const normalizedValue = range === 0 ? 0 : (value - stop1.pos) / range;

            const r = Math.round(stop1.r + normalizedValue * (stop2.r - stop1.r));
            const g = Math.round(stop1.g + normalizedValue * (stop2.g - stop1.g));
            const b = Math.round(stop1.b + normalizedValue * (stop2.b - stop1.b));

            return `rgb(${r}, ${g}, ${b})`;
        }

        // Handle WebSocket
        function connectWebSocket() {
            let ws = new WebSocket('ws://localhost:8080/ws');

            ws.onopen = function () {
                console.log('Connected to WebSocket');
                statusIndicator.className = 'status-indicator status-connected';
                statusText.textContent = 'Connected';
            };

            ws.onclose = function () {
                console.log('Disconnected from WebSocket');
                statusIndicator.className = 'status-indicator status-disconnected';
                statusText.textContent = 'Disconnected';

                // Try to reconnect after a delay
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = function (error) {
                console.error('WebSocket error:', error);
            };

            ws.onmessage = function (event) {
                try {
                    const data = JSON.parse(event.data);

                    // Handle different data types
                    if (Array.isArray(data)) {
                        fftData = data;
                    } else if (data.fftSize !== undefined) {
                        // Update metadata
                        fftSizeEl.textContent = data.fftSize;

                        if (data.windowType !== undefined && data.windowType < windowNames.length) {
                            windowTypeEl.textContent = windowNames[data.windowType];
                        }

                        if (data.energy !== undefined) {
                            energy = data.energy;
                            energyEl.textContent = energy.toFixed(6);

                            // Adjust base color based on energy
                            if (energy > 0.5) {
                                baseColor = [255, 50, 50]; // High energy: red
                            } else if (energy > 0.2) {
                                baseColor = [255, 150, 0]; // Medium energy: orange
                            } else {
                                baseColor = [0, 128, 255]; // Low energy: blue
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            };
        }

        // Initialize the visualization
        window.addEventListener('resize', setupCanvas);
        setupCanvas();
        updateVisualizationName();
        connectWebSocket();
        draw();
    </script>
</body>

</html>