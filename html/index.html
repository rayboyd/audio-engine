<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum Analyzer (Canvas)</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            color: #eee;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            /* Stack canvas and info */
            height: 100vh;
            align-items: center;
            /* Center horizontally */
            justify-content: center;
            /* Center vertically */
        }

        canvas {
            display: block;
            background-color: #1a1a1a;
            /* Slightly lighter background for canvas */
            /* Let JS control width/height */
        }

        .info-bar {
            padding: 10px;
            text-align: center;
            color: #0ff;
            font-size: 14px;
            width: 90%;
            /* Match canvas width */
            max-width: 1200px;
            /* Optional max width */
            box-sizing: border-box;
        }
    </style>
</head>

<body>
    <!-- Canvas for visualization -->
    <canvas id="visualizerCanvas"></canvas>
    <!-- Info bar below canvas -->
    <div class="info-bar">
        Spectrum Analyzer | FFT Bands: <span id="band-count">0</span> | Status: <span
            id="ws-status">Connecting...</span>
    </div>

    <script>
        const canvas = document.getElementById('visualizerCanvas');
        const ctx = canvas.getContext('2d');
        const bandCountElement = document.getElementById('band-count');
        const wsStatusElement = document.getElementById('ws-status');

        // --- Configuration ---
        const decayRate = 0.98; // How fast peaks fall
        const barSpacingRatio = 0.1; // e.g., 10% spacing between bars
        const minBarHeight = 1; // Minimum pixel height for a bar
        const peakLineColor = 'rgba(255, 255, 255, 0.7)';
        const peakLineWidth = 2; // Height of the peak line
        const smoothingFactor = 0.2; // Adjust 0.0 (slow) to 1.0 (instant) for smoothness

        // --- State ---
        let latestBandData = null;
        let peaks = [];
        let currentBarHeights = []; // Store the current animated height of each bar
        let numBands = 0;
        let animationFrameId = null; // To potentially cancel the loop

        // --- WebSocket Connection ---
        // Use the correct endpoint from your working version
        const socketUrl = 'ws://localhost:8080/fft';
        let socket;

        function connectWebSocket() {
            console.log(`Attempting to connect to ${socketUrl}...`);
            wsStatusElement.textContent = 'Connecting...';
            socket = new WebSocket(socketUrl);

            socket.onopen = function (event) {
                console.log('WebSocket connection opened');
                wsStatusElement.textContent = 'Connected';
                resizeCanvas(); // Set initial canvas size
                // Start the drawing loop if it's not already running
                if (!animationFrameId) {
                    drawVisualization();
                }
            };

            socket.onclose = function (event) {
                console.log(`WebSocket connection closed (Code: ${event.code}, Reason: ${event.reason})`);
                wsStatusElement.textContent = `Disconnected. Retrying...`;
                latestBandData = null; // Clear data
                numBands = 0; // Reset band count
                bandCountElement.textContent = numBands;
                // Optionally clear canvas or show disconnected state
                // ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                // ctx.fillRect(0, 0, canvas.width, canvas.height);
                // ctx.fillStyle = 'white';
                // ctx.textAlign = 'center';
                // ctx.fillText('Disconnected', canvas.width / 2, canvas.height / 2);

                // Attempt to reconnect after a delay
                setTimeout(connectWebSocket, 2000); // Retry after 2 seconds
            };

            socket.onerror = function (error) {
                console.error('WebSocket error:', error);
                wsStatusElement.textContent = 'Error';
                // Error handling might overlap with onclose, which usually follows errors
            };

            socket.onmessage = function (event) {
                try {
                    // Store the latest data. The drawing loop will pick it up.
                    latestBandData = JSON.parse(event.data);

                    // Update band count display if it changed
                    if (latestBandData && latestBandData.length !== numBands) {
                        numBands = latestBandData.length;
                        bandCountElement.textContent = numBands;
                        // Ensure peaks and currentBarHeights arrays match new band count
                        if (peaks.length !== numBands) {
                            peaks = new Array(numBands).fill(0);
                        }
                        // Initialize or resize currentBarHeights as well
                        if (currentBarHeights.length !== numBands) {
                            // If resizing, preserve existing heights or reset
                            const oldHeights = currentBarHeights;
                            currentBarHeights = new Array(numBands).fill(0);
                            // Optional: copy old heights if needed, though resetting might be fine
                            // for (let i = 0; i < Math.min(oldHeights.length, numBands); i++) {
                            //    currentBarHeights[i] = oldHeights[i];
                            // }
                        }
                    }

                } catch (e) {
                    console.error('Error processing FFT data:', e);
                    latestBandData = null; // Clear data on error
                }
            };
        }


        // --- Color Function (Same as your original) ---
        function getBarColor(index, value, totalBars) {
            // Ensure totalBars is at least 1 to avoid division by zero
            const numBands = Math.max(1, totalBars);
            // Avoid division by zero if numBands is 1
            const normalizedIndex = (numBands === 1) ? 0 : index / (numBands - 1);
            let r, g, b;

            if (normalizedIndex < 0.25) { // Blue to Cyan
                r = 0; g = Math.floor(255 * normalizedIndex * 4); b = 255;
            } else if (normalizedIndex < 0.5) { // Cyan to Green
                r = 0; g = 255; b = Math.floor(255 * (1 - (normalizedIndex - 0.25) * 4));
            } else if (normalizedIndex < 0.75) { // Green to Yellow
                r = Math.floor(255 * (normalizedIndex - 0.5) * 4); g = 255; b = 0;
            } else { // Yellow to Red
                r = 255; g = Math.floor(255 * (1 - (normalizedIndex - 0.75) * 4)); b = 0;
            }

            // Apply value intensity
            const intensity = Math.max(0.3, value); // Ensure minimum brightness
            r = Math.floor(r * intensity);
            g = Math.floor(g * intensity);
            b = Math.floor(b * intensity);

            return `rgb(${r}, ${g}, ${b})`;
        }

        // --- Drawing Function (Canvas Implementation) ---
        function drawVisualization() {
            // Request the next frame *before* drawing for a continuous loop
            animationFrameId = requestAnimationFrame(drawVisualization);

            // Ensure we have data and the canvas context is valid
            if (!latestBandData || !ctx) return;

            const bandData = latestBandData;
            const currentNumBands = bandData.length; // Use actual length from data
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            // Ensure peaks array is initialized correctly
            if (peaks.length !== currentNumBands) {
                peaks = new Array(currentNumBands).fill(0);
            }

            // --- Drawing ---

            // 1. Clear the canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            // Optional: Fill background if canvas style doesn't cover it
            // ctx.fillStyle = '#1a1a1a';
            // ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // 2. Calculate bar dimensions
            if (currentNumBands === 0) return; // Avoid division by zero if no bands

            const barWidth = canvasWidth / currentNumBands;
            const barSpacing = barWidth * barSpacingRatio;
            const effectiveBarWidth = Math.max(1, barWidth - barSpacing); // Ensure at least 1px width

            // 3. Draw each bar
            for (let i = 0; i < currentNumBands; i++) {
                const value = bandData[i] || 0; // Default to 0 if undefined

                // Clamp value for safety (0 to 1)
                const clampedValue = Math.max(0, Math.min(1, value));

                // Update peak with decay
                peaks[i] = Math.max(clampedValue, peaks[i] * decayRate);

                // Calculate bar height (scaled to canvas height)
                const barHeight = Math.max(minBarHeight, clampedValue * canvasHeight);
                const barX = i * barWidth + barSpacing / 2; // Center bar
                const barY = canvasHeight - barHeight; // Y position starts from bottom

                // Draw the main bar
                ctx.fillStyle = getBarColor(i, clampedValue, currentNumBands);
                ctx.fillRect(barX, barY, effectiveBarWidth, barHeight);

                // Draw the peak indicator
                if (peaks[i] > 0) {
                    const peakHeight = Math.max(minBarHeight, peaks[i] * canvasHeight);
                    const peakY = canvasHeight - peakHeight;
                    // Ensure peak line doesn't draw above the canvas top
                    const effectivePeakY = Math.max(0, peakY - peakLineWidth / 2);

                    ctx.fillStyle = peakLineColor;
                    ctx.fillRect(barX, effectivePeakY, effectiveBarWidth, peakLineWidth);
                }
            }
        }

        // --- Canvas Resizing ---
        function resizeCanvas() {
            // Make canvas fill a large portion, e.g., 90% width, 60% height
            const desiredWidth = window.innerWidth * 0.9;
            const desiredHeight = window.innerHeight * 0.6;

            // Optional: Set a max width for very large screens
            canvas.width = Math.min(desiredWidth, 1200);
            canvas.height = desiredHeight;

            // Adjust info bar width to match canvas
            const infoBar = document.querySelector('.info-bar');
            if (infoBar) {
                infoBar.style.width = `${canvas.width}px`;
            }


            console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);

            // Redrawing will happen automatically in the next animation frame
        }

        // --- Initialization ---
        window.addEventListener('resize', resizeCanvas); // Adjust canvas on window resize
        connectWebSocket(); // Initial connection attempt

    </script>
</body>

</html>