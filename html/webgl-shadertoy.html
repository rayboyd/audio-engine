<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shadertoy Example</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            color: #eee;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            background-color: #000;
            /* Black background for shader */
            width: 100%;
            /* Fill container */
            height: 100%;
        }

        .container {
            width: 80vw;
            /* Adjust size as needed */
            height: 80vh;
            border: 1px solid #333;
        }

        .info-bar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 15px;
            background-color: rgba(0, 0, 0, 0.5);
            color: #0ff;
            font-size: 14px;
            border-radius: 3px;
        }
    </style>
</head>

<body>
    <div class="container">
        <canvas id="visualizerCanvasST"></canvas>
    </div>
    <div class="info-bar">
        Shadertoy Port | Time: <span id="time-display">0.00</span>s | Res: <span id="res-display">0x0</span>
    </div>

    <!-- Vertex Shader: Simple pass-through for a full-screen quad -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position; // Input vertex position (-1 to 1)
        varying vec2 v_uv;         // Pass normalized UV coords (0 to 1) to fragment shader

        void main() {
            // Directly use the position for clip space
            gl_Position = vec4(a_position, 0.0, 1.0);
            // Convert from clip space (-1 to 1) to UV space (0 to 1)
            v_uv = a_position * 0.5 + 0.5;
        }
    </script>

    <!-- Fragment Shader: Adapt Shadertoy code here -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        // Varying input from vertex shader (normalized UV coords)
        varying vec2 v_uv;

        // Uniforms mimicking Shadertoy inputs
        uniform vec2 u_resolution; // Viewport resolution (pixels)
        uniform float u_time;      // Time (seconds)
        // uniform vec4 u_mouse;   // Mouse coords (xy: current, zw: click) - Add if needed
        // uniform sampler2D iChannel0; // Example texture input - Add if needed

        // --- PASTE SHADERTOY FRAGMENT SHADER CODE BELOW ---
        // Remember to:
        // 1. Replace `fragCoord` with `v_uv * u_resolution`
        // 2. Replace `iResolution` with `u_resolution`
        // 3. Replace `iTime` with `u_time`
        // 4. Replace `iMouse` with `u_mouse` (if used)
        // 5. Replace `texture(iChannelN, uv)` with `texture2D(iChannelN, uv)`
        // 6. Replace the output `fragColor = ...` with `gl_FragColor = ...`

        // Example placeholder (replace with actual Shadertoy code):
        void main() {
            vec2 uv = v_uv; // Use normalized UV coordinates (0 to 1)
            vec3 col = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0, 2, 4));
            gl_FragColor = vec4(col, 1.0);
        }
        // --- END OF SHADERTOY CODE ---

    </script>

    <script>
        const canvas = document.getElementById('visualizerCanvasST');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        const timeDisplay = document.getElementById('time-display');
        const resDisplay = document.getElementById('res-display');

        // --- WebGL State ---
        let glProgram = null;
        let positionBuffer = null;
        let positionAttributeLocation = -1;
        let resolutionUniformLocation = null;
        let timeUniformLocation = null;
        // let mouseUniformLocation = null; // Add if needed

        let startTime = performance.now();
        let animationFrameId = null;

        // --- WebGL Initialization ---
        function initWebGL() {
            if (!gl) {
                alert('WebGL is not supported by your browser.');
                return false;
            }

            // Compile shaders
            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            // Link program
            glProgram = createProgram(gl, vertexShader, fragmentShader);
            if (!glProgram) return false;

            // Look up attribute and uniform locations
            positionAttributeLocation = gl.getAttribLocation(glProgram, "a_position");
            resolutionUniformLocation = gl.getUniformLocation(glProgram, "u_resolution");
            timeUniformLocation = gl.getUniformLocation(glProgram, "u_time");
            // mouseUniformLocation = gl.getUniformLocation(glProgram, "u_mouse"); // Add if needed

            // --- Create Buffer for a Fullscreen Quad ---
            // Two triangles covering the entire clip space (-1 to 1)
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                -1, -1, // Triangle 1
                1, -1,
                -1, 1,
                -1, 1, // Triangle 2
                1, -1,
                1, 1,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            gl.enableVertexAttribArray(positionAttributeLocation);

            return true;
        }

        // --- Shader Compilation Helpers (from previous examples) ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) return shader;
            console.error(`Shader compile error (${type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'}):`, gl.getShaderInfoLog(shader));
            gl.deleteShader(shader); return null;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            if (!vertexShader || !fragmentShader) return null;
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            const success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) return program;
            console.error("Program link error:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program); return null;
        }

        // --- Drawing Function ---
        function drawVisualization(now) {
            animationFrameId = requestAnimationFrame(drawVisualization);

            if (!gl || !glProgram) return;

            const currentTime = (now - startTime) / 1000.0; // Time in seconds

            // --- Resize Check & Viewport Update ---
            // Check if canvas needs resizing based on its container
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                console.log(`WebGL Canvas resized to ${canvas.width}x${canvas.height}`);
                resDisplay.textContent = `${canvas.width}x${canvas.height}`;
            }

            // --- WebGL Drawing ---
            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(glProgram);

            // --- Set Attributes ---
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(
                positionAttributeLocation,
                2,         // 2 components per vertex (x, y)
                gl.FLOAT,  // Data type
                false,     // Normalize
                0,         // Stride (0 = auto)
                0          // Offset (0 = start)
            );

            // --- Set Uniforms ---
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(timeUniformLocation, currentTime);
            // Add mouse uniform update here if needed
            // gl.uniform4f(mouseUniformLocation, mouseX, mouseY, clickX, clickY);

            // --- Draw the Quad ---
            gl.drawArrays(gl.TRIANGLES, 0, 6); // 6 vertices for the two triangles

            // Update info display
            timeDisplay.textContent = currentTime.toFixed(2);
        }

        // --- Initialization ---
        if (initWebGL()) {
            startTime = performance.now(); // Reset start time after init
            resizeCanvas(); // Initial resize and viewport set
            drawVisualization(startTime); // Start the render loop
        } else {
            const container = document.querySelector('.container');
            if (container) container.innerHTML = '<p style="color: red; text-align: center;">WebGL Initialization Failed. Your browser might not support WebGL.</p>';
            wsStatusElement.textContent = 'WebGL Init Failed';
        }

        // --- Resize Handling ---
        // Debounced resize function
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // The resize check happens inside drawVisualization now
                // We just need to ensure it runs after resize settles
                console.log("Window resized, check will occur in next frame.");
            }, 100); // Adjust debounce delay if needed
        }
        window.addEventListener('resize', handleResize);

        // Initial call to set size correctly
        function resizeCanvas() {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                resDisplay.textContent = `${canvas.width}x${canvas.height}`;
            }
        }


    </script>
</body>

</html>