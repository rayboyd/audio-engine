<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Particle Wave Visualizer</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .info-bar {
            padding: 10px;
            text-align: center;
            color: #0ff;
            font-size: 14px;
            width: 90%;
            max-width: 1200px;
            box-sizing: border-box;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            z-index: 10;
        }

        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 10;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import Stats.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
</head>

<body>
    <canvas id="webglCanvas"></canvas>
    <div id="stats"></div>
    <div class="info-bar">
        Particle Wave | FFT Bands: <span id="band-count">0</span> | Status: <span id="ws-status">Connecting...</span> |
        Color Mode: <span id="color-mode">0</span> (Press 'C')
    </div>

    <!-- SHADERS -->
    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float iTime;
        uniform float uDCMagnitude;
        uniform float uAvgMid;
        uniform float uAvgHigh;
        uniform vec2 iResolution;
        uniform int uColorMode; // Added color mode uniform

        attribute float particleIndex;
        attribute vec3 initialPosition;

        varying vec3 vColor;
        varying float vIntensity;

        // --- Tunable Parameters ---
        const float BASE_SIZE = 1.0;
        const float SIZE_WAVE_AMPLITUDE = 10.0;
        const float BASE_WAVE_FREQ = 2.0;
        const float DC_FREQ_SCALE = 8.0;
        const float PARTICLE_COUNT_X = 24.0;

        // Helper: Map range
        float mapRange(float value, float inMin, float inMax, float outMin, float outMax) {
            return clamp(((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin, outMin, outMax);
        }

        // Helper: Rainbow color
        vec3 rainbow(float h) {
            h = mod(h, 1.0);
            float r = abs(h * 6.0 - 3.0) - 1.0;
            float g = 2.0 - abs(h * 6.0 - 2.0);
            float b = 2.0 - abs(h * 6.0 - 4.0);
            return clamp(vec3(r, g, b), 0.0, 1.0);
        }

        void main() {
            vec3 pos = position;

            // 1. Calculate Wave Frequency
            float waveFrequency = BASE_WAVE_FREQ * (1.0 + uDCMagnitude * DC_FREQ_SCALE);

            // 2. Calculate Size Wave
            float timeOffset = particleIndex * 0.05;
            float sizeWave = 0.5 + 0.5 * sin(iTime * waveFrequency + timeOffset);

            // 3. Calculate Particle Size
            float currentSize = BASE_SIZE + SIZE_WAVE_AMPLITUDE * pow(uAvgMid, 0.8) * sizeWave;

            // 4. Calculate Color and Intensity based on uColorMode
            float colorCoord = mapRange(initialPosition.x, -PARTICLE_COUNT_X * 0.5 * 1.5, PARTICLE_COUNT_X * 0.5 * 1.5, 0.0, 1.0); // Use particleSpacing in map range
            float dynamicColorShift = 0.03 * (1.0 + uAvgHigh * 2.0);

            if (uColorMode == 0) { // Rainbow (Original)
                vColor = rainbow(colorCoord + iTime * dynamicColorShift);
            } else if (uColorMode == 1) { // Low Freq Color (Blue -> Cyan based on Mid)
                vColor = mix(vec3(0.0, 0.1, 0.8), vec3(0.0, 0.8, 0.8), pow(uAvgMid, 0.7));
            } else if (uColorMode == 2) { // Mid Freq Color (Green -> Yellow based on Mid)
                vColor = mix(vec3(0.1, 0.7, 0.1), vec3(0.8, 0.8, 0.1), pow(uAvgMid, 0.7));
            } else if (uColorMode == 3) { // High Freq Color (Orange -> Red -> Magenta based on High)
                vColor = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.0, 0.5), pow(uAvgHigh, 0.7));
            } else if (uColorMode == 4) { // Size Wave Color (White -> Grey)
                vColor = vec3(0.5 + sizeWave * 0.5);
            } else { // Default fallback (Rainbow)
                 vColor = rainbow(colorCoord + iTime * dynamicColorShift);
            }

            vIntensity = 0.5 + pow(uAvgMid, 1.2) * 1.5; // Intensity based on Mid freq

            // 5. Set Position and Size
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // Perspective scaling
            float perspectiveFactor = 1.0 / -mvPosition.z;
            // Adjust multiplier for desired screen size appearance
            gl_PointSize = currentSize * perspectiveFactor * 50.0;
            gl_PointSize = max(1.0, gl_PointSize); // Ensure minimum size
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        varying float vIntensity;

        void main() {
            // Create a circular shape for the point
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            float alpha = smoothstep(0.5, 0.45, dist); // Soft circular edge

            if (alpha < 0.01) discard; // Discard transparent fragments

            gl_FragColor = vec4(vColor * vIntensity, alpha);
        }
    </script>

    <!-- MAIN JAVASCRIPT LOGIC -->
    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('webglCanvas');
        const bandCountElement = document.getElementById('band-count');
        const wsStatusElement = document.getElementById('ws-status');
        const statsContainer = document.getElementById('stats');
        const colorModeElement = document.getElementById('color-mode'); // Get span for color mode display

        // --- Configuration ---
        const particleCountX = 64;
        const particleCountY = 32;
        const particleSpacing = 1.5;
        const totalParticles = particleCountX * particleCountY;

        // --- Global State Variables ---
        let latestBandData = null;
        let numBands = 0;
        let animationFrameId = null;
        let scene, camera, renderer, particleSystem, shaderMaterial, stats;
        let isInitialized = false;
        const clock = new THREE.Clock();
        let avgLowSmooth = 0.0, avgMidSmooth = 0.0, avgHighSmooth = 0.0;
        let dcMagnitudeSmooth = 0.0;
        const avgSmoothingFactor = 0.1;
        let currentColorMode = 0; // Add state for color mode
        const numColorModes = 5; // Total number of color modes implemented in shader

        // --- Three.js Setup Function ---
        function initThreeJS() {
            if (isInitialized) return;
            console.log("Initializing Three.js for Particle Wave...");

            try {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);

                // Camera (Perspective)
                camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);

                // Calculate grid dimensions
                const gridWidth = particleCountX * particleSpacing;
                // Calculate required distance to fit grid width in FOV
                const fovRadians = camera.fov * (Math.PI / 180);
                // Adjust distance calculation based on aspect ratio
                const distance = (gridWidth / 2) / (Math.tan(fovRadians / 2) * camera.aspect);
                // Position camera slightly further back than calculated minimum
                camera.position.set(0, 0, distance * 1.1 + (particleCountY * particleSpacing / 4)); // Add slight offset based on height too
                camera.lookAt(0, 0, 0);
                console.log(`Calculated camera distance: ${distance.toFixed(2)}, Set to: ${camera.position.z.toFixed(2)}`);

                // Renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);

                // Stats.js
                if (statsContainer) {
                    try {
                        stats = new Stats(); stats.showPanel(0);
                        if (stats.dom) { statsContainer.innerHTML = ''; statsContainer.appendChild(stats.dom); }
                        else console.error("stats.dom missing");
                    } catch (e) { console.error("Stats init error:", e); stats = null; }
                } else console.error("stats container not found");

                // --- Particle Geometry Setup ---
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(totalParticles * 3);
                const initialPositions = new Float32Array(totalParticles * 3);
                const particleIndices = new Float32Array(totalParticles);

                let i = 0;
                for (let ix = 0; ix < particleCountX; ix++) {
                    for (let iy = 0; iy < particleCountY; iy++) {
                        const x = (ix - particleCountX / 2 + 0.5) * particleSpacing;
                        const y = (iy - particleCountY / 2 + 0.5) * particleSpacing;
                        const z = 0;
                        positions[i * 3 + 0] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
                        initialPositions[i * 3 + 0] = x; initialPositions[i * 3 + 1] = y; initialPositions[i * 3 + 2] = z;
                        particleIndices[i] = i;
                        i++;
                    }
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('initialPosition', new THREE.BufferAttribute(initialPositions, 3));
                geometry.setAttribute('particleIndex', new THREE.BufferAttribute(particleIndices, 1));

                // --- Shader Material Setup ---
                shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        iTime: { value: 0.0 },
                        iResolution: { value: new THREE.Vector2(width, height) },
                        uDCMagnitude: { value: 0.0 },
                        uAvgMid: { value: 0.0 },
                        uAvgHigh: { value: 0.0 },
                        uColorMode: { value: currentColorMode } // Add color mode uniform
                    },
                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                // --- Particle System ---
                particleSystem = new THREE.Points(geometry, shaderMaterial);
                scene.add(particleSystem);

                isInitialized = true;
                console.log("Particle Wave Initialized Successfully.");
                animate();

            } catch (error) {
                console.error("Error during Particle Wave initialization:", error);
                wsStatusElement.textContent = "WebGL Init Error";
            }
        }

        // --- Calculate Averages (and DC) ---
        function calculateAverages() {
            let avgLow = 0, avgMid = 0, avgHigh = 0, dcMag = 0;
            if (latestBandData && numBands > 0) {
                const lowEnd = Math.floor(numBands * 0.10);
                const midEnd = Math.floor(numBands * 0.40);
                let lowSum = 0, midSum = 0, highSum = 0;
                let lowCount = 0, midCount = 0, highCount = 0;
                dcMag = latestBandData[0] || 0;
                for (let i = 0; i < numBands; i++) {
                    const magnitude = latestBandData[i] || 0;
                    if (i > 0 && i < lowEnd) { lowSum += magnitude; lowCount++; }
                    else if (i >= lowEnd && i < midEnd) { midSum += magnitude; midCount++; }
                    else if (i >= midEnd) { highSum += magnitude; highCount++; }
                }
                avgLow = lowCount > 0 ? lowSum / lowCount : 0;
                avgMid = midCount > 0 ? midSum / midCount : 0;
                avgHigh = highCount > 0 ? highSum / highCount : 0;
            }
            dcMagnitudeSmooth += (dcMag - dcMagnitudeSmooth) * avgSmoothingFactor;
            avgLowSmooth += (avgLow - avgLowSmooth) * avgSmoothingFactor;
            avgMidSmooth += (avgMid - avgMidSmooth) * avgSmoothingFactor;
            avgHighSmooth += (avgHigh - avgHighSmooth) * avgSmoothingFactor;
            dcMagnitudeSmooth = Math.max(0.0, dcMagnitudeSmooth);
            avgLowSmooth = Math.max(0.0, avgLowSmooth);
            avgMidSmooth = Math.max(0.0, avgMidSmooth);
            avgHighSmooth = Math.max(0.0, avgHighSmooth);
            return { dc: dcMagnitudeSmooth, low: avgLowSmooth, mid: avgMidSmooth, high: avgHighSmooth };
        }

        // --- Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (!isInitialized || !renderer || !scene || !camera || !shaderMaterial) return;
            if (stats) stats.begin();
            const averages = calculateAverages();
            const elapsedTime = clock.getElapsedTime();
            shaderMaterial.uniforms.iTime.value = elapsedTime;
            shaderMaterial.uniforms.uDCMagnitude.value = averages.dc;
            shaderMaterial.uniforms.uAvgMid.value = averages.mid;
            shaderMaterial.uniforms.uAvgHigh.value = averages.high;
            renderer.render(scene, camera);
            if (stats) stats.end();
        }

        // --- WebSocket Connection ---
        const socketUrl = 'ws://localhost:8080/fft';
        let socket;
        function connectWebSocket() {
            console.log(`Attempting to connect to ${socketUrl}...`);
            wsStatusElement.textContent = 'Connecting...';
            if (socket && socket.readyState !== WebSocket.CLOSED) socket.close();
            socket = new WebSocket(socketUrl);
            socket.onopen = function (event) {
                console.log('WebSocket connection opened');
                wsStatusElement.textContent = 'Connected';
                if (!isInitialized) initThreeJS();
                handleResize(); // Call resize after init to set initial camera correctly
            };
            socket.onclose = function (event) {
                console.log(`WebSocket closed (Code: ${event.code})`);
                wsStatusElement.textContent = `Disconnected. Retrying...`;
                latestBandData = null;
                setTimeout(connectWebSocket, 2000);
            };
            socket.onerror = function (error) { console.error('WebSocket error:', error); wsStatusElement.textContent = 'Connection Error'; };
            socket.onmessage = function (event) {
                try {
                    const data = JSON.parse(event.data);
                    let newData = (data && data.magnitudes) ? data.magnitudes : (Array.isArray(data) ? data : null);
                    if (newData) {
                        if (newData.length !== numBands) {
                            console.log(`Band count changed: ${numBands} -> ${newData.length}`);
                            numBands = newData.length; bandCountElement.textContent = numBands;
                        }
                        latestBandData = newData;
                    } else {
                        latestBandData = null; if (numBands !== 0) { numBands = 0; bandCountElement.textContent = numBands; }
                    }
                } catch (e) {
                    console.error('Failed to parse WebSocket message:', e);
                    latestBandData = null; if (numBands !== 0) { numBands = 0; bandCountElement.textContent = numBands; }
                }
            };
        }

        // --- Window Resize Handler ---
        function handleResize() {
            if (!isInitialized || !camera || !renderer || !shaderMaterial || !shaderMaterial.uniforms) return;
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            shaderMaterial.uniforms.iResolution.value.set(width, height);

            // Recalculate camera distance on resize to maintain framing
            const gridWidth = particleCountX * particleSpacing;
            const fovRadians = camera.fov * (Math.PI / 180);
            // Adjust distance calculation based on aspect ratio
            const distance = (gridWidth / 2) / (Math.tan(fovRadians / 2) * camera.aspect);
            // Position camera slightly further back than calculated minimum
            camera.position.z = distance * 1.1 + (particleCountY * particleSpacing / 4); // Add slight offset based on height too
            camera.lookAt(0, 0, 0);
            console.log(`Canvas resized to ${width}x${height}, Camera Z adjusted to: ${camera.position.z.toFixed(2)}`);
        }

        // --- Key Press Handler for Color Mode ---
        function handleKeyPress(event) {
            if (event.key === 'c' || event.key === 'C') {
                if (!isInitialized || !shaderMaterial) return;
                currentColorMode = (currentColorMode + 1) % numColorModes;
                shaderMaterial.uniforms.uColorMode.value = currentColorMode;
                if (colorModeElement) colorModeElement.textContent = currentColorMode; // Update info bar
                console.log(`Color Mode changed to: ${currentColorMode}`);
            }
        }

        // --- Initial Setup ---
        window.addEventListener('resize', handleResize);
        window.addEventListener('keypress', handleKeyPress); // Add key listener
        connectWebSocket();

    </script>
</body>

</html>