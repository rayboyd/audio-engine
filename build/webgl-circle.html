<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrum Analyzer (WebGL Circular)</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            color: #eee;
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            background-color: #1a1a1a;
        }

        .info-bar {
            padding: 10px;
            text-align: center;
            color: #0ff;
            font-size: 14px;
            width: 90%;
            max-width: 800px;
            box-sizing: border-box;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }
    </style>
</head>

<body>
    <canvas id="visualizerCanvasGL2"></canvas>
    <div class="info-bar">
        WebGL Circular | FFT Bands: <span id="band-count">0</span> | Status: <span id="ws-status">Connecting...</span>
    </div>

    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute float a_bandIndex;
        attribute float a_fftValue;
        attribute vec2 a_position; // Base quad vertex (-0.5 to 0.5)

        uniform float u_numBands;
        uniform vec2 u_resolution;
        uniform float u_innerRadius; // Inner radius of the circle
        uniform float u_maxBarHeight; // Max radial height of a bar

        varying vec3 v_color;

        const float PI = 3.14159265359;

        // Simple color function (same as before)
        vec3 getBarColor(float index, float value, float totalBars) {
            float numBands = max(1.0, totalBars);
            float normalizedIndex = (numBands == 1.0) ? 0.0 : index / (numBands - 1.0);
            float r, g, b;
            if (normalizedIndex < 0.25) { r = 0.0; g = normalizedIndex * 4.0; b = 1.0; }
            else if (normalizedIndex < 0.5) { r = 0.0; g = 1.0; b = 1.0 - (normalizedIndex - 0.25) * 4.0; }
            else if (normalizedIndex < 0.75) { r = (normalizedIndex - 0.5) * 4.0; g = 1.0; b = 0.0; }
            else { r = 1.0; g = 1.0 - (normalizedIndex - 0.75) * 4.0; b = 0.0; }
            float intensity = max(0.3, value);
            return vec3(r * intensity, g * intensity, b * intensity);
        }

        // 2D rotation matrix
        mat2 rotate2d(float angle) {
            return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        }

        void main() {
            // Calculate center angle for this band
            float centerAngle = (a_bandIndex / u_numBands) * 2.0 * PI;

            // Calculate the angular width for this bar (e.g., 80% of the band's segment)
            float totalAnglePerBand = (2.0 * PI / u_numBands);
            float barAngularWidth = totalAnglePerBand * 0.8;

            // Calculate the radial height of the bar
            float barRadialHeight = max(1.0 / u_resolution.y, a_fftValue) * u_maxBarHeight; // Use normalized value, ensure min height

            // Map base quad vertex a_position (-0.5 to 0.5) to the bar's segment
            // a_position.x maps to angle offset (-0.5 -> -barAngularWidth/2, +0.5 -> +barAngularWidth/2)
            // a_position.y maps to radius offset (-0.5 -> innerRadius, +0.5 -> innerRadius + barRadialHeight)
            float currentAngle = centerAngle + a_position.x * barAngularWidth;
            float currentRadius = u_innerRadius + (a_position.y + 0.5) * barRadialHeight; // Map y from [-0.5, 0.5] to [0, 1] then scale

            // Convert polar coordinates (currentAngle, currentRadius) to Cartesian pixel coordinates relative to center
            vec2 positionPixels = vec2(cos(currentAngle), sin(currentAngle)) * currentRadius;

            // Convert pixel coordinates (relative to center) to clip space (-1.0 to 1.0)
            // Divide by half the resolution because clip space goes from -1 to +1
            vec2 clipSpace = positionPixels / (u_resolution * 0.5);

            // Adjust for aspect ratio to prevent stretching (important if canvas isn't square)
            float aspect = u_resolution.x / u_resolution.y;
             if (aspect > 1.0) {
                 // Wider than tall, scale X
                 clipSpace.x /= aspect;
             } else {
                 // Taller than wide (or square), scale Y
                 clipSpace.y *= aspect;
             }

            gl_Position = vec4(clipSpace, 0, 1);

            // Pass color (calculated the same way)
            v_color = getBarColor(a_bandIndex, a_fftValue, u_numBands);
        }
    </script>

    <!-- Fragment Shader (Identical to previous) -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec3 v_color;
        void main() {
            gl_FragColor = vec4(v_color, 1.0);
        }
    </script>


    <script>
        const canvas = document.getElementById('visualizerCanvasGL2');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        const bandCountElement = document.getElementById('band-count');
        const wsStatusElement = document.getElementById('ws-status');

        // --- WebGL State ---
        let glProgram = null;
        let positionBuffer = null, bandIndexBuffer = null, fftValueBuffer = null;
        let positionAttributeLocation = -1, bandIndexAttributeLocation = -1, fftValueAttributeLocation = -1;
        let resolutionUniformLocation = null, numBandsUniformLocation = null;
        let innerRadiusUniformLocation = null, maxBarHeightUniformLocation = null; // New uniforms
        let numBands = 0;
        let bandIndices = null, fftValues = null;

        // --- Config & Smoothing ---
        const smoothingFactor = 0.2;
        let currentFFTValues = null;
        let innerRadius = 100.0; // Inner radius in pixels
        let maxBarHeight = 150.0; // Max bar height in pixels

        // --- WebSocket State ---
        const socketUrl = 'ws://localhost:8080/fft';
        let socket;
        let latestBandData = null;
        let animationFrameId = null;

        // --- WebGL Initialization ---
        function initWebGL() {
            if (!gl) { alert('WebGL not supported.'); return false; }

            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            glProgram = createProgram(gl, vertexShader, fragmentShader);
            if (!glProgram) return false;

            // Attribute locations
            positionAttributeLocation = gl.getAttribLocation(glProgram, "a_position");
            bandIndexAttributeLocation = gl.getAttribLocation(glProgram, "a_bandIndex");
            fftValueAttributeLocation = gl.getAttribLocation(glProgram, "a_fftValue");

            // Uniform locations
            resolutionUniformLocation = gl.getUniformLocation(glProgram, "u_resolution");
            numBandsUniformLocation = gl.getUniformLocation(glProgram, "u_numBands");
            innerRadiusUniformLocation = gl.getUniformLocation(glProgram, "u_innerRadius"); // New
            maxBarHeightUniformLocation = gl.getUniformLocation(glProgram, "u_maxBarHeight"); // New

            // Buffers (same setup as before)
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5]), gl.STATIC_DRAW);
            bandIndexBuffer = gl.createBuffer();
            fftValueBuffer = gl.createBuffer();

            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.enableVertexAttribArray(bandIndexAttributeLocation);
            gl.enableVertexAttribArray(fftValueAttributeLocation);

            // Instancing setup (same as before)
            const ext = gl.getExtension('ANGLE_instanced_arrays');
            if (!ext) { alert('ANGLE_instanced_arrays not supported'); return false; }
            ext.vertexAttribDivisorANGLE(bandIndexAttributeLocation, 1);
            ext.vertexAttribDivisorANGLE(fftValueAttributeLocation, 1);

            return true;
        }

        // --- Shader Helpers (Identical to previous) ---
        function createShader(gl, type, source) { /* ... */
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error("Shader compile error:", gl.getShaderInfoLog(shader));
            gl.deleteShader(shader); return null;
        }
        function createProgram(gl, vs, fs) { /* ... */
            const program = gl.createProgram();
            gl.attachShader(program, vs); gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
            console.error("Program link error:", gl.getProgramInfoLog(program));
            gl.deleteProgram(program); return null;
        }

        // --- WebSocket Connection (Identical logic, updates numBands etc.) ---
        function connectWebSocket() {
            console.log(`Connecting to ${socketUrl}...`); wsStatusElement.textContent = 'Connecting...';
            socket = new WebSocket(socketUrl);
            socket.onopen = () => { console.log('WS open'); wsStatusElement.textContent = 'Connected'; resizeCanvas(); if (!animationFrameId) drawVisualization(); };
            socket.onclose = (e) => { console.log(`WS closed (Code: ${e.code})`); wsStatusElement.textContent = `Disconnected. Retrying...`; latestBandData = null; setTimeout(connectWebSocket, 2000); };
            socket.onerror = (err) => { console.error('WS error:', err); wsStatusElement.textContent = 'Error'; };
            socket.onmessage = (event) => {
                try {
                    latestBandData = JSON.parse(event.data);
                    if (latestBandData && latestBandData.length !== numBands) {
                        numBands = latestBandData.length; bandCountElement.textContent = numBands;
                        bandIndices = new Float32Array(numBands);
                        for (let i = 0; i < numBands; ++i) bandIndices[i] = i;
                        gl.bindBuffer(gl.ARRAY_BUFFER, bandIndexBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, bandIndices, gl.STATIC_DRAW);
                        fftValues = new Float32Array(numBands);
                        currentFFTValues = new Float32Array(numBands).fill(0);
                    }
                } catch (e) { console.error('FFT data error:', e); latestBandData = null; }
            };
        }

        // --- Drawing Function (WebGL Circular) ---
        function drawVisualization() {
            animationFrameId = requestAnimationFrame(drawVisualization);
            if (!gl || !glProgram || !latestBandData || numBands === 0) return;

            const bandData = latestBandData;

            // Apply Smoothing (same as before)
            for (let i = 0; i < numBands; i++) {
                const targetValue = Math.max(0, Math.min(1, bandData[i] || 0));
                currentFFTValues[i] += (targetValue - currentFFTValues[i]) * smoothingFactor;
                fftValues[i] = currentFFTValues[i];
            }

            // --- WebGL Drawing ---
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0.05, 0.05, 0.08, 1.0); // Slightly different background
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(glProgram);

            // Set Attributes (same setup, different data for fftValueBuffer)
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, bandIndexBuffer);
            gl.vertexAttribPointer(bandIndexAttributeLocation, 1, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, fftValueBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, fftValues, gl.DYNAMIC_DRAW); // Upload smoothed data
            gl.vertexAttribPointer(fftValueAttributeLocation, 1, gl.FLOAT, false, 0, 0);

            // Set Uniforms (including new ones)
            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(numBandsUniformLocation, numBands);
            gl.uniform1f(innerRadiusUniformLocation, innerRadius); // Pass radius
            gl.uniform1f(maxBarHeightUniformLocation, maxBarHeight); // Pass max height

            // Draw Instanced (same call as before)
            const ext = gl.getExtension('ANGLE_instanced_arrays');
            if (ext) {
                ext.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, 4, numBands);
            }
        }

        // --- Canvas Resizing ---
        function resizeCanvas() {
            // Aim for a square-ish canvas centered
            const size = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.8, 800);
            if (canvas.width !== size || canvas.height !== size) {
                canvas.width = size;
                canvas.height = size;
                // Update radius based on new size?
                innerRadius = size * 0.25; // e.g., 25% of canvas size
                maxBarHeight = size * 0.35; // e.g., 35% of canvas size
                console.log(`WebGL Canvas resized to ${canvas.width}x${canvas.height}`);
            }
            // Adjust info bar width to match canvas
            const infoBar = document.querySelector('.info-bar');
            if (infoBar) infoBar.style.width = `${canvas.width}px`;
        }

        // --- Initialization ---
        if (initWebGL()) {
            window.addEventListener('resize', resizeCanvas);
            connectWebSocket();
        } else {
            wsStatusElement.textContent = 'WebGL Init Failed';
        }

    </script>
</body>

</html>